{"version":3,"sources":["node_modules/phoenix/priv/static/phoenix.js","node_modules/phoenix_html/priv/static/phoenix_html.js","js/app.js","js/socket.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC55CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AAAA;AACA;AACA;AACA;AAHA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtEA;AAAA","file":"../priv/static/js/app.js","sourcesContent":["\nrequire.register(\"phoenix/priv/static/phoenix.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix\");\n  (function() {\n    (function (global, factory) {\r\ntypeof exports === 'object' ? factory(exports) :\r\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\r\nfactory(global.Phoenix = global.Phoenix || {});\r\n}(this, (function (exports) {\r\n\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\n/**\r\n * Phoenix Channels JavaScript client\r\n *\r\n * ## Socket Connection\r\n *\r\n * A single connection is established to the server and\r\n * channels are multiplexed over the connection.\r\n * Connect to the server using the `Socket` class:\r\n *\r\n * ```javascript\r\n *     let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\r\n *     socket.connect()\r\n * ```\r\n *\r\n * The `Socket` constructor takes the mount point of the socket,\r\n * the authentication params, as well as options that can be found in\r\n * the Socket docs, such as configuring the `LongPoll` transport, and\r\n * heartbeat.\r\n *\r\n * ## Channels\r\n *\r\n * Channels are isolated, concurrent processes on the server that\r\n * subscribe to topics and broker events between the client and server.\r\n * To join a channel, you must provide the topic, and channel params for\r\n * authorization. Here's an example chat room example where `\"new_msg\"`\r\n * events are listened for, messages are pushed to the server, and\r\n * the channel is joined with ok/error/timeout matches:\r\n *\r\n * ```javascript\r\n *     let channel = socket.channel(\"room:123\", {token: roomToken})\r\n *     channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\r\n *     $input.onEnter( e => {\r\n *       channel.push(\"new_msg\", {body: e.target.val}, 10000)\r\n *        .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\r\n *        .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\r\n *        .receive(\"timeout\", () => console.log(\"Networking issue...\") )\r\n *     })\r\n *     channel.join()\r\n *       .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\r\n *       .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\r\n *       .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\") )\r\n *```\r\n *\r\n * ## Joining\r\n *\r\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\r\n * `channel.params`, which are sent up on `channel.join()`.\r\n * Subsequent rejoins will send up the modified params for\r\n * updating authorization params, or passing up last_message_id information.\r\n * Successful joins receive an \"ok\" status, while unsuccessful joins\r\n * receive \"error\".\r\n *\r\n * ## Duplicate Join Subscriptions\r\n *\r\n * While the client may join any number of topics on any number of channels,\r\n * the client may only hold a single subscription for each unique topic at any\r\n * given time. When attempting to create a duplicate subscription,\r\n * the server will close the existing channel, log a warning, and\r\n * spawn a new channel for the topic. The client will have their\r\n * `channel.onClose` callbacks fired for the existing channel, and the new\r\n * channel join will have its receive hooks processed as normal.\r\n *\r\n * ## Pushing Messages\r\n *\r\n * From the previous example, we can see that pushing messages to the server\r\n * can be done with `channel.push(eventName, payload)` and we can optionally\r\n * receive responses from the push. Additionally, we can use\r\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\r\n *  and take action after some period of waiting. The default timeout is 5000ms.\r\n *\r\n *\r\n * ## Socket Hooks\r\n *\r\n * Lifecycle events of the multiplexed connection can be hooked into via\r\n * `socket.onError()` and `socket.onClose()` events, ie:\r\n *\r\n * ```javascript\r\n *     socket.onError( () => console.log(\"there was an error with the connection!\") )\r\n *     socket.onClose( () => console.log(\"the connection dropped\") )\r\n * ```\r\n *\r\n *\r\n * ## Channel Hooks\r\n *\r\n * For each joined channel, you can bind to `onError` and `onClose` events\r\n * to monitor the channel lifecycle, ie:\r\n *\r\n * ```javascript\r\n *     channel.onError( () => console.log(\"there was an error!\") )\r\n *     channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\r\n * ```\r\n *\r\n * ### onError hooks\r\n *\r\n * `onError` hooks are invoked if the socket connection drops, or the channel\r\n * crashes on the server. In either case, a channel rejoin is attempted\r\n * automatically in an exponential backoff manner.\r\n *\r\n * ### onClose hooks\r\n *\r\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\r\n * closed on the server, or 2). The client explicitly closed, by calling\r\n * `channel.leave()`\r\n *\r\n *\r\n * ## Presence\r\n *\r\n * The `Presence` object provides features for syncing presence information\r\n * from the server with the client and handling presences joining and leaving.\r\n *\r\n * ### Syncing initial state from the server\r\n *\r\n * `Presence.syncState` is used to sync the list of presences on the server\r\n * with the client's state. An optional `onJoin` and `onLeave` callback can\r\n * be provided to react to changes in the client's local presences across\r\n * disconnects and reconnects with the server.\r\n *\r\n * `Presence.syncDiff` is used to sync a diff of presence join and leave\r\n * events from the server, as they happen. Like `syncState`, `syncDiff`\r\n * accepts optional `onJoin` and `onLeave` callbacks to react to a user\r\n * joining or leaving from a device.\r\n *\r\n * ### Listing Presences\r\n *\r\n * `Presence.list` is used to return a list of presence information\r\n * based on the local state of metadata. By default, all presence\r\n * metadata is returned, but a `listBy` function can be supplied to\r\n * allow the client to select which metadata to use for a given presence.\r\n * For example, you may have a user online from different devices with\r\n * a metadata status of \"online\", but they have set themselves to \"away\"\r\n * on another device. In this case, the app may choose to use the \"away\"\r\n * status for what appears on the UI. The example below defines a `listBy`\r\n * function which prioritizes the first metadata which was registered for\r\n * each user. This could be the first tab they opened, or the first device\r\n * they came online from:\r\n *\r\n * ```javascript\r\n *     let state = {}\r\n *     state = Presence.syncState(state, stateFromServer)\r\n *     let listBy = (id, {metas: [first, ...rest]}) => {\r\n *       first.count = rest.length + 1 // count of this user's presences\r\n *       first.id = id\r\n *       return first\r\n *     }\r\n *     let onlineUsers = Presence.list(state, listBy)\r\n * ```\r\n *\r\n *\r\n * ### Example Usage\r\n *```javascript\r\n *     // detect if user has joined for the 1st time or from another tab/device\r\n *     let onJoin = (id, current, newPres) => {\r\n *       if(!current){\r\n *         console.log(\"user has entered for the first time\", newPres)\r\n *       } else {\r\n *         console.log(\"user additional presence\", newPres)\r\n *       }\r\n *     }\r\n *     // detect if user has left from all tabs/devices, or is still present\r\n *     let onLeave = (id, current, leftPres) => {\r\n *       if(current.metas.length === 0){\r\n *         console.log(\"user has left from all devices\", leftPres)\r\n *       } else {\r\n *         console.log(\"user left from a device\", leftPres)\r\n *       }\r\n *     }\r\n *     let presences = {} // client's initial empty presence state\r\n *     // receive initial presence data from server, sent after join\r\n *     myChannel.on(\"presence_state\", state => {\r\n *       presences = Presence.syncState(presences, state, onJoin, onLeave)\r\n *       displayUsers(Presence.list(presences))\r\n *     })\r\n *     // receive \"presence_diff\" from server, containing join/leave events\r\n *     myChannel.on(\"presence_diff\", diff => {\r\n *       presences = Presence.syncDiff(presences, diff, onJoin, onLeave)\r\n *       this.setState({users: Presence.list(room.presences, listBy)})\r\n *     })\r\n * ```\r\n * @module phoenix\r\n */\r\n\r\nvar VSN = \"2.0.0\";\r\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\r\nvar DEFAULT_TIMEOUT = 10000;\r\nvar WS_CLOSE_NORMAL = 1000;\r\nvar CHANNEL_STATES = {\r\n  closed: \"closed\",\r\n  errored: \"errored\",\r\n  joined: \"joined\",\r\n  joining: \"joining\",\r\n  leaving: \"leaving\"\r\n};\r\nvar CHANNEL_EVENTS = {\r\n  close: \"phx_close\",\r\n  error: \"phx_error\",\r\n  join: \"phx_join\",\r\n  reply: \"phx_reply\",\r\n  leave: \"phx_leave\"\r\n};\r\nvar CHANNEL_LIFECYCLE_EVENTS = [CHANNEL_EVENTS.close, CHANNEL_EVENTS.error, CHANNEL_EVENTS.join, CHANNEL_EVENTS.reply, CHANNEL_EVENTS.leave];\r\nvar TRANSPORTS = {\r\n  longpoll: \"longpoll\",\r\n  websocket: \"websocket\"\r\n};\r\n\r\n/**\r\n * Initializes the Push\r\n * @param {Channel} channel - The Channel\r\n * @param {string} event - The event, for example `\"phx_join\"`\r\n * @param {Object} payload - The payload, for example `{user_id: 123}`\r\n * @param {number} timeout - The push timeout in milliseconds\r\n */\r\n\r\nvar Push = function () {\r\n  function Push(channel, event, payload, timeout) {\r\n    _classCallCheck(this, Push);\r\n\r\n    this.channel = channel;\r\n    this.event = event;\r\n    this.payload = payload || {};\r\n    this.receivedResp = null;\r\n    this.timeout = timeout;\r\n    this.timeoutTimer = null;\r\n    this.recHooks = [];\r\n    this.sent = false;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number} timeout\r\n   */\r\n\r\n\r\n  _createClass(Push, [{\r\n    key: \"resend\",\r\n    value: function resend(timeout) {\r\n      this.timeout = timeout;\r\n      this.reset();\r\n      this.send();\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n\r\n  }, {\r\n    key: \"send\",\r\n    value: function send() {\r\n      if (this.hasReceived(\"timeout\")) {\r\n        return;\r\n      }\r\n      this.startTimeout();\r\n      this.sent = true;\r\n      this.channel.socket.push({\r\n        topic: this.channel.topic,\r\n        event: this.event,\r\n        payload: this.payload,\r\n        ref: this.ref,\r\n        join_ref: this.channel.joinRef()\r\n      });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} status\r\n     * @param {*} callback\r\n     */\r\n\r\n  }, {\r\n    key: \"receive\",\r\n    value: function receive(status, callback) {\r\n      if (this.hasReceived(status)) {\r\n        callback(this.receivedResp.response);\r\n      }\r\n\r\n      this.recHooks.push({ status: status, callback: callback });\r\n      return this;\r\n    }\r\n\r\n    // private\r\n\r\n  }, {\r\n    key: \"reset\",\r\n    value: function reset() {\r\n      this.cancelRefEvent();\r\n      this.ref = null;\r\n      this.refEvent = null;\r\n      this.receivedResp = null;\r\n      this.sent = false;\r\n    }\r\n  }, {\r\n    key: \"matchReceive\",\r\n    value: function matchReceive(_ref) {\r\n      var status = _ref.status,\r\n          response = _ref.response,\r\n          ref = _ref.ref;\r\n\r\n      this.recHooks.filter(function (h) {\r\n        return h.status === status;\r\n      }).forEach(function (h) {\r\n        return h.callback(response);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"cancelRefEvent\",\r\n    value: function cancelRefEvent() {\r\n      if (!this.refEvent) {\r\n        return;\r\n      }\r\n      this.channel.off(this.refEvent);\r\n    }\r\n  }, {\r\n    key: \"cancelTimeout\",\r\n    value: function cancelTimeout() {\r\n      clearTimeout(this.timeoutTimer);\r\n      this.timeoutTimer = null;\r\n    }\r\n  }, {\r\n    key: \"startTimeout\",\r\n    value: function startTimeout() {\r\n      var _this = this;\r\n\r\n      if (this.timeoutTimer) {\r\n        this.cancelTimeout();\r\n      }\r\n      this.ref = this.channel.socket.makeRef();\r\n      this.refEvent = this.channel.replyEventName(this.ref);\r\n\r\n      this.channel.on(this.refEvent, function (payload) {\r\n        _this.cancelRefEvent();\r\n        _this.cancelTimeout();\r\n        _this.receivedResp = payload;\r\n        _this.matchReceive(payload);\r\n      });\r\n\r\n      this.timeoutTimer = setTimeout(function () {\r\n        _this.trigger(\"timeout\", {});\r\n      }, this.timeout);\r\n    }\r\n  }, {\r\n    key: \"hasReceived\",\r\n    value: function hasReceived(status) {\r\n      return this.receivedResp && this.receivedResp.status === status;\r\n    }\r\n  }, {\r\n    key: \"trigger\",\r\n    value: function trigger(status, response) {\r\n      this.channel.trigger(this.refEvent, { status: status, response: response });\r\n    }\r\n  }]);\r\n\r\n  return Push;\r\n}();\r\n\r\n/**\r\n *\r\n * @param {string} topic\r\n * @param {Object} params\r\n * @param {Socket} socket\r\n */\r\n\r\n\r\nvar Channel = exports.Channel = function () {\r\n  function Channel(topic, params, socket) {\r\n    var _this2 = this;\r\n\r\n    _classCallCheck(this, Channel);\r\n\r\n    this.state = CHANNEL_STATES.closed;\r\n    this.topic = topic;\r\n    this.params = params || {};\r\n    this.socket = socket;\r\n    this.bindings = [];\r\n    this.timeout = this.socket.timeout;\r\n    this.joinedOnce = false;\r\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\r\n    this.pushBuffer = [];\r\n    this.rejoinTimer = new Timer(function () {\r\n      return _this2.rejoinUntilConnected();\r\n    }, this.socket.reconnectAfterMs);\r\n    this.joinPush.receive(\"ok\", function () {\r\n      _this2.state = CHANNEL_STATES.joined;\r\n      _this2.rejoinTimer.reset();\r\n      _this2.pushBuffer.forEach(function (pushEvent) {\r\n        return pushEvent.send();\r\n      });\r\n      _this2.pushBuffer = [];\r\n    });\r\n    this.onClose(function () {\r\n      _this2.rejoinTimer.reset();\r\n      _this2.socket.log(\"channel\", \"close \" + _this2.topic + \" \" + _this2.joinRef());\r\n      _this2.state = CHANNEL_STATES.closed;\r\n      _this2.socket.remove(_this2);\r\n    });\r\n    this.onError(function (reason) {\r\n      if (_this2.isLeaving() || _this2.isClosed()) {\r\n        return;\r\n      }\r\n      _this2.socket.log(\"channel\", \"error \" + _this2.topic, reason);\r\n      _this2.state = CHANNEL_STATES.errored;\r\n      _this2.rejoinTimer.scheduleTimeout();\r\n    });\r\n    this.joinPush.receive(\"timeout\", function () {\r\n      if (!_this2.isJoining()) {\r\n        return;\r\n      }\r\n      _this2.socket.log(\"channel\", \"timeout \" + _this2.topic + \" (\" + _this2.joinRef() + \")\", _this2.joinPush.timeout);\r\n      var leavePush = new Push(_this2, CHANNEL_EVENTS.leave, {}, _this2.timeout);\r\n      leavePush.send();\r\n      _this2.state = CHANNEL_STATES.errored;\r\n      _this2.joinPush.reset();\r\n      _this2.rejoinTimer.scheduleTimeout();\r\n    });\r\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\r\n      _this2.trigger(_this2.replyEventName(ref), payload);\r\n    });\r\n  }\r\n\r\n  _createClass(Channel, [{\r\n    key: \"rejoinUntilConnected\",\r\n    value: function rejoinUntilConnected() {\r\n      this.rejoinTimer.scheduleTimeout();\r\n      if (this.socket.isConnected()) {\r\n        this.rejoin();\r\n      }\r\n    }\r\n  }, {\r\n    key: \"join\",\r\n    value: function join() {\r\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\r\n\r\n      if (this.joinedOnce) {\r\n        throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\r\n      } else {\r\n        this.joinedOnce = true;\r\n        this.rejoin(timeout);\r\n        return this.joinPush;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"onClose\",\r\n    value: function onClose(callback) {\r\n      this.on(CHANNEL_EVENTS.close, callback);\r\n    }\r\n  }, {\r\n    key: \"onError\",\r\n    value: function onError(callback) {\r\n      this.on(CHANNEL_EVENTS.error, function (reason) {\r\n        return callback(reason);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"on\",\r\n    value: function on(event, callback) {\r\n      this.bindings.push({ event: event, callback: callback });\r\n    }\r\n  }, {\r\n    key: \"off\",\r\n    value: function off(event) {\r\n      this.bindings = this.bindings.filter(function (bind) {\r\n        return bind.event !== event;\r\n      });\r\n    }\r\n  }, {\r\n    key: \"canPush\",\r\n    value: function canPush() {\r\n      return this.socket.isConnected() && this.isJoined();\r\n    }\r\n  }, {\r\n    key: \"push\",\r\n    value: function push(event, payload) {\r\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\r\n\r\n      if (!this.joinedOnce) {\r\n        throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use channel.join() before pushing events\";\r\n      }\r\n      var pushEvent = new Push(this, event, payload, timeout);\r\n      if (this.canPush()) {\r\n        pushEvent.send();\r\n      } else {\r\n        pushEvent.startTimeout();\r\n        this.pushBuffer.push(pushEvent);\r\n      }\r\n\r\n      return pushEvent;\r\n    }\r\n\r\n    /** Leaves the channel\r\n     *\r\n     * Unsubscribes from server events, and\r\n     * instructs channel to terminate on server\r\n     *\r\n     * Triggers onClose() hooks\r\n     *\r\n     * To receive leave acknowledgements, use the a `receive`\r\n     * hook to bind to the server ack, ie:\r\n     *\r\n     * ```javascript\r\n     *     channel.leave().receive(\"ok\", () => alert(\"left!\") )\r\n     * ```\r\n     */\r\n\r\n  }, {\r\n    key: \"leave\",\r\n    value: function leave() {\r\n      var _this3 = this;\r\n\r\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\r\n\r\n      this.state = CHANNEL_STATES.leaving;\r\n      var onClose = function onClose() {\r\n        _this3.socket.log(\"channel\", \"leave \" + _this3.topic);\r\n        _this3.trigger(CHANNEL_EVENTS.close, \"leave\");\r\n      };\r\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\r\n      leavePush.receive(\"ok\", function () {\r\n        return onClose();\r\n      }).receive(\"timeout\", function () {\r\n        return onClose();\r\n      });\r\n      leavePush.send();\r\n      if (!this.canPush()) {\r\n        leavePush.trigger(\"ok\", {});\r\n      }\r\n\r\n      return leavePush;\r\n    }\r\n\r\n    /**\r\n     * Overridable message hook\r\n     *\r\n     * Receives all events for specialized message handling\r\n     * before dispatching to the channel callbacks.\r\n     *\r\n     * Must return the payload, modified or unmodified\r\n     */\r\n\r\n  }, {\r\n    key: \"onMessage\",\r\n    value: function onMessage(event, payload, ref) {\r\n      return payload;\r\n    }\r\n\r\n    // private\r\n\r\n  }, {\r\n    key: \"isMember\",\r\n    value: function isMember(topic, event, payload, joinRef) {\r\n      if (this.topic !== topic) {\r\n        return false;\r\n      }\r\n      var isLifecycleEvent = CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0;\r\n\r\n      if (joinRef && isLifecycleEvent && joinRef !== this.joinRef()) {\r\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic: topic, event: event, payload: payload, joinRef: joinRef });\r\n        return false;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"joinRef\",\r\n    value: function joinRef() {\r\n      return this.joinPush.ref;\r\n    }\r\n  }, {\r\n    key: \"sendJoin\",\r\n    value: function sendJoin(timeout) {\r\n      this.state = CHANNEL_STATES.joining;\r\n      this.joinPush.resend(timeout);\r\n    }\r\n  }, {\r\n    key: \"rejoin\",\r\n    value: function rejoin() {\r\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\r\n      if (this.isLeaving()) {\r\n        return;\r\n      }\r\n      this.sendJoin(timeout);\r\n    }\r\n  }, {\r\n    key: \"trigger\",\r\n    value: function trigger(event, payload, ref, joinRef) {\r\n      var _this4 = this;\r\n\r\n      var handledPayload = this.onMessage(event, payload, ref, joinRef);\r\n      if (payload && !handledPayload) {\r\n        throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\r\n      }\r\n\r\n      this.bindings.filter(function (bind) {\r\n        return bind.event === event;\r\n      }).map(function (bind) {\r\n        return bind.callback(handledPayload, ref, joinRef || _this4.joinRef());\r\n      });\r\n    }\r\n  }, {\r\n    key: \"replyEventName\",\r\n    value: function replyEventName(ref) {\r\n      return \"chan_reply_\" + ref;\r\n    }\r\n  }, {\r\n    key: \"isClosed\",\r\n    value: function isClosed() {\r\n      return this.state === CHANNEL_STATES.closed;\r\n    }\r\n  }, {\r\n    key: \"isErrored\",\r\n    value: function isErrored() {\r\n      return this.state === CHANNEL_STATES.errored;\r\n    }\r\n  }, {\r\n    key: \"isJoined\",\r\n    value: function isJoined() {\r\n      return this.state === CHANNEL_STATES.joined;\r\n    }\r\n  }, {\r\n    key: \"isJoining\",\r\n    value: function isJoining() {\r\n      return this.state === CHANNEL_STATES.joining;\r\n    }\r\n  }, {\r\n    key: \"isLeaving\",\r\n    value: function isLeaving() {\r\n      return this.state === CHANNEL_STATES.leaving;\r\n    }\r\n  }]);\r\n\r\n  return Channel;\r\n}();\r\n\r\nvar Serializer = {\r\n  encode: function encode(msg, callback) {\r\n    var payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\r\n    return callback(JSON.stringify(payload));\r\n  },\r\n  decode: function decode(rawPayload, callback) {\r\n    var _JSON$parse = JSON.parse(rawPayload),\r\n        _JSON$parse2 = _slicedToArray(_JSON$parse, 5),\r\n        join_ref = _JSON$parse2[0],\r\n        ref = _JSON$parse2[1],\r\n        topic = _JSON$parse2[2],\r\n        event = _JSON$parse2[3],\r\n        payload = _JSON$parse2[4];\r\n\r\n    return callback({ join_ref: join_ref, ref: ref, topic: topic, event: event, payload: payload });\r\n  }\r\n};\r\n\r\n/** Initializes the Socket\r\n *\r\n *\r\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\r\n *\r\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\r\n *                                               `\"wss://example.com\"`\r\n *                                               `\"/socket\"` (inherited host & protocol)\r\n * @param {Object} opts - Optional configuration\r\n * @param {string} opts.transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\r\n *\r\n * Defaults to WebSocket with automatic LongPoll fallback.\r\n * @param {Function} opts.encode - The function to encode outgoing messages.\r\n *\r\n * Defaults to JSON:\r\n *\r\n * ```javascript\r\n * (payload, callback) => callback(JSON.stringify(payload))\r\n * ```\r\n *\r\n * @param {Function} opts.decode - The function to decode incoming messages.\r\n *\r\n * Defaults to JSON:\r\n *\r\n * ```javascript\r\n * (payload, callback) => callback(JSON.parse(payload))\r\n * ```\r\n *\r\n * @param {number} opts.timeout - The default timeout in milliseconds to trigger push timeouts.\r\n *\r\n * Defaults `DEFAULT_TIMEOUT`\r\n * @param {number} opts.heartbeatIntervalMs - The millisec interval to send a heartbeat message\r\n * @param {number} opts.reconnectAfterMs - The optional function that returns the millsec reconnect interval.\r\n *\r\n * Defaults to stepped backoff of:\r\n *\r\n * ```javascript\r\n *  function(tries){\r\n *    return [1000, 5000, 10000][tries - 1] || 10000\r\n *  }\r\n * ```\r\n * @param {Function} opts.logger - The optional function for specialized logging, ie:\r\n * ```javascript\r\n * logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n * ```\r\n *\r\n * @param {number}  opts.longpollerTimeout - The maximum timeout of a long poll AJAX request.\r\n *\r\n * Defaults to 20s (double the server long poll timer).\r\n *\r\n * @param {Object}  opts.params - The optional params to pass when connecting\r\n *\r\n *\r\n*/\r\n\r\nvar Socket = exports.Socket = function () {\r\n  function Socket(endPoint) {\r\n    var _this5 = this;\r\n\r\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n    _classCallCheck(this, Socket);\r\n\r\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\r\n    this.channels = [];\r\n    this.sendBuffer = [];\r\n    this.ref = 0;\r\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\r\n    this.transport = opts.transport || window.WebSocket || LongPoll;\r\n    this.defaultEncoder = Serializer.encode;\r\n    this.defaultDecoder = Serializer.decode;\r\n    if (this.transport !== LongPoll) {\r\n      this.encode = opts.encode || this.defaultEncoder;\r\n      this.decode = opts.decode || this.defaultDecoder;\r\n    } else {\r\n      this.encode = this.defaultEncoder;\r\n      this.decode = this.defaultDecoder;\r\n    }\r\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\r\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\r\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\r\n    };\r\n    this.logger = opts.logger || function () {}; // noop\r\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\r\n    this.params = opts.params || {};\r\n    this.endPoint = endPoint + \"/\" + TRANSPORTS.websocket;\r\n    this.heartbeatTimer = null;\r\n    this.pendingHeartbeatRef = null;\r\n    this.reconnectTimer = new Timer(function () {\r\n      _this5.disconnect(function () {\r\n        return _this5.connect();\r\n      });\r\n    }, this.reconnectAfterMs);\r\n  }\r\n\r\n  _createClass(Socket, [{\r\n    key: \"protocol\",\r\n    value: function protocol() {\r\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\r\n    }\r\n  }, {\r\n    key: \"endPointURL\",\r\n    value: function endPointURL() {\r\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params), { vsn: VSN });\r\n      if (uri.charAt(0) !== \"/\") {\r\n        return uri;\r\n      }\r\n      if (uri.charAt(1) === \"/\") {\r\n        return this.protocol() + \":\" + uri;\r\n      }\r\n\r\n      return this.protocol() + \"://\" + location.host + uri;\r\n    }\r\n  }, {\r\n    key: \"disconnect\",\r\n    value: function disconnect(callback, code, reason) {\r\n      if (this.conn) {\r\n        this.conn.onclose = function () {}; // noop\r\n        if (code) {\r\n          this.conn.close(code, reason || \"\");\r\n        } else {\r\n          this.conn.close();\r\n        }\r\n        this.conn = null;\r\n      }\r\n      callback && callback();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\r\n     */\r\n\r\n  }, {\r\n    key: \"connect\",\r\n    value: function connect(params) {\r\n      var _this6 = this;\r\n\r\n      if (params) {\r\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\r\n        this.params = params;\r\n      }\r\n      if (this.conn) {\r\n        return;\r\n      }\r\n\r\n      this.conn = new this.transport(this.endPointURL());\r\n      this.conn.timeout = this.longpollerTimeout;\r\n      this.conn.onopen = function () {\r\n        return _this6.onConnOpen();\r\n      };\r\n      this.conn.onerror = function (error) {\r\n        return _this6.onConnError(error);\r\n      };\r\n      this.conn.onmessage = function (event) {\r\n        return _this6.onConnMessage(event);\r\n      };\r\n      this.conn.onclose = function (event) {\r\n        return _this6.onConnClose(event);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Logs the message. Override `this.logger` for specialized logging. noops by default\r\n     * @param {string} kind\r\n     * @param {string} msg\r\n     * @param {Object} data\r\n     */\r\n\r\n  }, {\r\n    key: \"log\",\r\n    value: function log(kind, msg, data) {\r\n      this.logger(kind, msg, data);\r\n    }\r\n\r\n    // Registers callbacks for connection state change events\r\n    //\r\n    // Examples\r\n    //\r\n    //    socket.onError(function(error){ alert(\"An error occurred\") })\r\n    //\r\n\r\n  }, {\r\n    key: \"onOpen\",\r\n    value: function onOpen(callback) {\r\n      this.stateChangeCallbacks.open.push(callback);\r\n    }\r\n  }, {\r\n    key: \"onClose\",\r\n    value: function onClose(callback) {\r\n      this.stateChangeCallbacks.close.push(callback);\r\n    }\r\n  }, {\r\n    key: \"onError\",\r\n    value: function onError(callback) {\r\n      this.stateChangeCallbacks.error.push(callback);\r\n    }\r\n  }, {\r\n    key: \"onMessage\",\r\n    value: function onMessage(callback) {\r\n      this.stateChangeCallbacks.message.push(callback);\r\n    }\r\n  }, {\r\n    key: \"onConnOpen\",\r\n    value: function onConnOpen() {\r\n      var _this7 = this;\r\n\r\n      this.log(\"transport\", \"connected to \" + this.endPointURL());\r\n      this.flushSendBuffer();\r\n      this.reconnectTimer.reset();\r\n      if (!this.conn.skipHeartbeat) {\r\n        clearInterval(this.heartbeatTimer);\r\n        this.heartbeatTimer = setInterval(function () {\r\n          return _this7.sendHeartbeat();\r\n        }, this.heartbeatIntervalMs);\r\n      }\r\n      this.stateChangeCallbacks.open.forEach(function (callback) {\r\n        return callback();\r\n      });\r\n    }\r\n  }, {\r\n    key: \"onConnClose\",\r\n    value: function onConnClose(event) {\r\n      this.log(\"transport\", \"close\", event);\r\n      this.triggerChanError();\r\n      clearInterval(this.heartbeatTimer);\r\n      this.reconnectTimer.scheduleTimeout();\r\n      this.stateChangeCallbacks.close.forEach(function (callback) {\r\n        return callback(event);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"onConnError\",\r\n    value: function onConnError(error) {\r\n      this.log(\"transport\", error);\r\n      this.triggerChanError();\r\n      this.stateChangeCallbacks.error.forEach(function (callback) {\r\n        return callback(error);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"triggerChanError\",\r\n    value: function triggerChanError() {\r\n      this.channels.forEach(function (channel) {\r\n        return channel.trigger(CHANNEL_EVENTS.error);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"connectionState\",\r\n    value: function connectionState() {\r\n      switch (this.conn && this.conn.readyState) {\r\n        case SOCKET_STATES.connecting:\r\n          return \"connecting\";\r\n        case SOCKET_STATES.open:\r\n          return \"open\";\r\n        case SOCKET_STATES.closing:\r\n          return \"closing\";\r\n        default:\r\n          return \"closed\";\r\n      }\r\n    }\r\n  }, {\r\n    key: \"isConnected\",\r\n    value: function isConnected() {\r\n      return this.connectionState() === \"open\";\r\n    }\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove(channel) {\r\n      this.channels = this.channels.filter(function (c) {\r\n        return c.joinRef() !== channel.joinRef();\r\n      });\r\n    }\r\n  }, {\r\n    key: \"channel\",\r\n    value: function channel(topic) {\r\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n      var chan = new Channel(topic, chanParams, this);\r\n      this.channels.push(chan);\r\n      return chan;\r\n    }\r\n  }, {\r\n    key: \"push\",\r\n    value: function push(data) {\r\n      var _this8 = this;\r\n\r\n      var topic = data.topic,\r\n          event = data.event,\r\n          payload = data.payload,\r\n          ref = data.ref,\r\n          join_ref = data.join_ref;\r\n\r\n      var callback = function callback() {\r\n        _this8.encode(data, function (result) {\r\n          _this8.conn.send(result);\r\n        });\r\n      };\r\n      this.log(\"push\", topic + \" \" + event + \" (\" + join_ref + \", \" + ref + \")\", payload);\r\n      if (this.isConnected()) {\r\n        callback();\r\n      } else {\r\n        this.sendBuffer.push(callback);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Return the next message ref, accounting for overflows\r\n     */\r\n\r\n  }, {\r\n    key: \"makeRef\",\r\n    value: function makeRef() {\r\n      var newRef = this.ref + 1;\r\n      if (newRef === this.ref) {\r\n        this.ref = 0;\r\n      } else {\r\n        this.ref = newRef;\r\n      }\r\n\r\n      return this.ref.toString();\r\n    }\r\n  }, {\r\n    key: \"sendHeartbeat\",\r\n    value: function sendHeartbeat() {\r\n      if (!this.isConnected()) {\r\n        return;\r\n      }\r\n      if (this.pendingHeartbeatRef) {\r\n        this.pendingHeartbeatRef = null;\r\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\r\n        this.conn.close(WS_CLOSE_NORMAL, \"hearbeat timeout\");\r\n        return;\r\n      }\r\n      this.pendingHeartbeatRef = this.makeRef();\r\n      this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\r\n    }\r\n  }, {\r\n    key: \"flushSendBuffer\",\r\n    value: function flushSendBuffer() {\r\n      if (this.isConnected() && this.sendBuffer.length > 0) {\r\n        this.sendBuffer.forEach(function (callback) {\r\n          return callback();\r\n        });\r\n        this.sendBuffer = [];\r\n      }\r\n    }\r\n  }, {\r\n    key: \"onConnMessage\",\r\n    value: function onConnMessage(rawMessage) {\r\n      var _this9 = this;\r\n\r\n      this.decode(rawMessage.data, function (msg) {\r\n        var topic = msg.topic,\r\n            event = msg.event,\r\n            payload = msg.payload,\r\n            ref = msg.ref,\r\n            join_ref = msg.join_ref;\r\n\r\n        if (ref && ref === _this9.pendingHeartbeatRef) {\r\n          _this9.pendingHeartbeatRef = null;\r\n        }\r\n\r\n        _this9.log(\"receive\", (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\r\n        _this9.channels.filter(function (channel) {\r\n          return channel.isMember(topic, event, payload, join_ref);\r\n        }).forEach(function (channel) {\r\n          return channel.trigger(event, payload, ref, join_ref);\r\n        });\r\n        _this9.stateChangeCallbacks.message.forEach(function (callback) {\r\n          return callback(msg);\r\n        });\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return Socket;\r\n}();\r\n\r\nvar LongPoll = exports.LongPoll = function () {\r\n  function LongPoll(endPoint) {\r\n    _classCallCheck(this, LongPoll);\r\n\r\n    this.endPoint = null;\r\n    this.token = null;\r\n    this.skipHeartbeat = true;\r\n    this.onopen = function () {}; // noop\r\n    this.onerror = function () {}; // noop\r\n    this.onmessage = function () {}; // noop\r\n    this.onclose = function () {}; // noop\r\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\r\n    this.readyState = SOCKET_STATES.connecting;\r\n\r\n    this.poll();\r\n  }\r\n\r\n  _createClass(LongPoll, [{\r\n    key: \"normalizeEndpoint\",\r\n    value: function normalizeEndpoint(endPoint) {\r\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\r\n    }\r\n  }, {\r\n    key: \"endpointURL\",\r\n    value: function endpointURL() {\r\n      return Ajax.appendParams(this.pollEndpoint, { token: this.token });\r\n    }\r\n  }, {\r\n    key: \"closeAndRetry\",\r\n    value: function closeAndRetry() {\r\n      this.close();\r\n      this.readyState = SOCKET_STATES.connecting;\r\n    }\r\n  }, {\r\n    key: \"ontimeout\",\r\n    value: function ontimeout() {\r\n      this.onerror(\"timeout\");\r\n      this.closeAndRetry();\r\n    }\r\n  }, {\r\n    key: \"poll\",\r\n    value: function poll() {\r\n      var _this10 = this;\r\n\r\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\r\n        return;\r\n      }\r\n\r\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\r\n        if (resp) {\r\n          var status = resp.status,\r\n              token = resp.token,\r\n              messages = resp.messages;\r\n\r\n          _this10.token = token;\r\n        } else {\r\n          var status = 0;\r\n        }\r\n\r\n        switch (status) {\r\n          case 200:\r\n            messages.forEach(function (msg) {\r\n              return _this10.onmessage({ data: msg });\r\n            });\r\n            _this10.poll();\r\n            break;\r\n          case 204:\r\n            _this10.poll();\r\n            break;\r\n          case 410:\r\n            _this10.readyState = SOCKET_STATES.open;\r\n            _this10.onopen();\r\n            _this10.poll();\r\n            break;\r\n          case 0:\r\n          case 500:\r\n            _this10.onerror();\r\n            _this10.closeAndRetry();\r\n            break;\r\n          default:\r\n            throw \"unhandled poll status \" + status;\r\n        }\r\n      });\r\n    }\r\n  }, {\r\n    key: \"send\",\r\n    value: function send(body) {\r\n      var _this11 = this;\r\n\r\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\r\n        if (!resp || resp.status !== 200) {\r\n          _this11.onerror(resp && resp.status);\r\n          _this11.closeAndRetry();\r\n        }\r\n      });\r\n    }\r\n  }, {\r\n    key: \"close\",\r\n    value: function close(code, reason) {\r\n      this.readyState = SOCKET_STATES.closed;\r\n      this.onclose();\r\n    }\r\n  }]);\r\n\r\n  return LongPoll;\r\n}();\r\n\r\nvar Ajax = exports.Ajax = function () {\r\n  function Ajax() {\r\n    _classCallCheck(this, Ajax);\r\n  }\r\n\r\n  _createClass(Ajax, null, [{\r\n    key: \"request\",\r\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\r\n      if (window.XDomainRequest) {\r\n        var req = new XDomainRequest(); // IE8, IE9\r\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\r\n      } else {\r\n        var _req = window.XMLHttpRequest ? new window.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\r\n        new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\r\n        this.xhrRequest(_req, method, endPoint, accept, body, timeout, ontimeout, callback);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"xdomainRequest\",\r\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\r\n      var _this12 = this;\r\n\r\n      req.timeout = timeout;\r\n      req.open(method, endPoint);\r\n      req.onload = function () {\r\n        var response = _this12.parseJSON(req.responseText);\r\n        callback && callback(response);\r\n      };\r\n      if (ontimeout) {\r\n        req.ontimeout = ontimeout;\r\n      }\r\n\r\n      // Work around bug in IE9 that requires an attached onprogress handler\r\n      req.onprogress = function () {};\r\n\r\n      req.send(body);\r\n    }\r\n  }, {\r\n    key: \"xhrRequest\",\r\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\r\n      var _this13 = this;\r\n\r\n      req.open(method, endPoint, true);\r\n      req.timeout = timeout;\r\n      req.setRequestHeader(\"Content-Type\", accept);\r\n      req.onerror = function () {\r\n        callback && callback(null);\r\n      };\r\n      req.onreadystatechange = function () {\r\n        if (req.readyState === _this13.states.complete && callback) {\r\n          var response = _this13.parseJSON(req.responseText);\r\n          callback(response);\r\n        }\r\n      };\r\n      if (ontimeout) {\r\n        req.ontimeout = ontimeout;\r\n      }\r\n\r\n      req.send(body);\r\n    }\r\n  }, {\r\n    key: \"parseJSON\",\r\n    value: function parseJSON(resp) {\r\n      if (!resp || resp === \"\") {\r\n        return null;\r\n      }\r\n\r\n      try {\r\n        return JSON.parse(resp);\r\n      } catch (e) {\r\n        console && console.log(\"failed to parse JSON response\", resp);\r\n        return null;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"serialize\",\r\n    value: function serialize(obj, parentKey) {\r\n      var queryStr = [];\r\n      for (var key in obj) {\r\n        if (!obj.hasOwnProperty(key)) {\r\n          continue;\r\n        }\r\n        var paramKey = parentKey ? parentKey + \"[\" + key + \"]\" : key;\r\n        var paramVal = obj[key];\r\n        if ((typeof paramVal === \"undefined\" ? \"undefined\" : _typeof(paramVal)) === \"object\") {\r\n          queryStr.push(this.serialize(paramVal, paramKey));\r\n        } else {\r\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\r\n        }\r\n      }\r\n      return queryStr.join(\"&\");\r\n    }\r\n  }, {\r\n    key: \"appendParams\",\r\n    value: function appendParams(url, params) {\r\n      if (Object.keys(params).length === 0) {\r\n        return url;\r\n      }\r\n\r\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\r\n      return \"\" + url + prefix + this.serialize(params);\r\n    }\r\n  }]);\r\n\r\n  return Ajax;\r\n}();\r\n\r\nAjax.states = { complete: 4 };\r\n\r\nvar Presence = exports.Presence = {\r\n  syncState: function syncState(currentState, newState, onJoin, onLeave) {\r\n    var _this14 = this;\r\n\r\n    var state = this.clone(currentState);\r\n    var joins = {};\r\n    var leaves = {};\r\n\r\n    this.map(state, function (key, presence) {\r\n      if (!newState[key]) {\r\n        leaves[key] = presence;\r\n      }\r\n    });\r\n    this.map(newState, function (key, newPresence) {\r\n      var currentPresence = state[key];\r\n      if (currentPresence) {\r\n        var newRefs = newPresence.metas.map(function (m) {\r\n          return m.phx_ref;\r\n        });\r\n        var curRefs = currentPresence.metas.map(function (m) {\r\n          return m.phx_ref;\r\n        });\r\n        var joinedMetas = newPresence.metas.filter(function (m) {\r\n          return curRefs.indexOf(m.phx_ref) < 0;\r\n        });\r\n        var leftMetas = currentPresence.metas.filter(function (m) {\r\n          return newRefs.indexOf(m.phx_ref) < 0;\r\n        });\r\n        if (joinedMetas.length > 0) {\r\n          joins[key] = newPresence;\r\n          joins[key].metas = joinedMetas;\r\n        }\r\n        if (leftMetas.length > 0) {\r\n          leaves[key] = _this14.clone(currentPresence);\r\n          leaves[key].metas = leftMetas;\r\n        }\r\n      } else {\r\n        joins[key] = newPresence;\r\n      }\r\n    });\r\n    return this.syncDiff(state, { joins: joins, leaves: leaves }, onJoin, onLeave);\r\n  },\r\n  syncDiff: function syncDiff(currentState, _ref2, onJoin, onLeave) {\r\n    var joins = _ref2.joins,\r\n        leaves = _ref2.leaves;\r\n\r\n    var state = this.clone(currentState);\r\n    if (!onJoin) {\r\n      onJoin = function onJoin() {};\r\n    }\r\n    if (!onLeave) {\r\n      onLeave = function onLeave() {};\r\n    }\r\n\r\n    this.map(joins, function (key, newPresence) {\r\n      var currentPresence = state[key];\r\n      state[key] = newPresence;\r\n      if (currentPresence) {\r\n        var _state$key$metas;\r\n\r\n        (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(currentPresence.metas));\r\n      }\r\n      onJoin(key, currentPresence, newPresence);\r\n    });\r\n    this.map(leaves, function (key, leftPresence) {\r\n      var currentPresence = state[key];\r\n      if (!currentPresence) {\r\n        return;\r\n      }\r\n      var refsToRemove = leftPresence.metas.map(function (m) {\r\n        return m.phx_ref;\r\n      });\r\n      currentPresence.metas = currentPresence.metas.filter(function (p) {\r\n        return refsToRemove.indexOf(p.phx_ref) < 0;\r\n      });\r\n      onLeave(key, currentPresence, leftPresence);\r\n      if (currentPresence.metas.length === 0) {\r\n        delete state[key];\r\n      }\r\n    });\r\n    return state;\r\n  },\r\n  list: function list(presences, chooser) {\r\n    if (!chooser) {\r\n      chooser = function chooser(key, pres) {\r\n        return pres;\r\n      };\r\n    }\r\n\r\n    return this.map(presences, function (key, presence) {\r\n      return chooser(key, presence);\r\n    });\r\n  },\r\n\r\n\r\n  // private\r\n\r\n  map: function map(obj, func) {\r\n    return Object.getOwnPropertyNames(obj).map(function (key) {\r\n      return func(key, obj[key]);\r\n    });\r\n  },\r\n  clone: function clone(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n};\r\n\r\n/**\r\n *\r\n * Creates a timer that accepts a `timerCalc` function to perform\r\n * calculated timeout retries, such as exponential backoff.\r\n *\r\n * ## Examples\r\n *\r\n * ```javascript\r\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\r\n *      return [1000, 5000, 10000][tries - 1] || 10000\r\n *    })\r\n *    reconnectTimer.scheduleTimeout() // fires after 1000\r\n *    reconnectTimer.scheduleTimeout() // fires after 5000\r\n *    reconnectTimer.reset()\r\n *    reconnectTimer.scheduleTimeout() // fires after 1000\r\n * ```\r\n * @param {Function} callback\r\n * @param {Function} timerCalc\r\n */\r\n\r\nvar Timer = function () {\r\n  function Timer(callback, timerCalc) {\r\n    _classCallCheck(this, Timer);\r\n\r\n    this.callback = callback;\r\n    this.timerCalc = timerCalc;\r\n    this.timer = null;\r\n    this.tries = 0;\r\n  }\r\n\r\n  _createClass(Timer, [{\r\n    key: \"reset\",\r\n    value: function reset() {\r\n      this.tries = 0;\r\n      clearTimeout(this.timer);\r\n    }\r\n\r\n    /**\r\n     * Cancels any previous scheduleTimeout and schedules callback\r\n     */\r\n\r\n  }, {\r\n    key: \"scheduleTimeout\",\r\n    value: function scheduleTimeout() {\r\n      var _this15 = this;\r\n\r\n      clearTimeout(this.timer);\r\n\r\n      this.timer = setTimeout(function () {\r\n        _this15.tries = _this15.tries + 1;\r\n        _this15.callback();\r\n      }, this.timerCalc(this.tries + 1));\r\n    }\r\n  }]);\r\n\r\n  return Timer;\r\n}();\r\n\r\n})));\n  })();\n});","\nrequire.register(\"phoenix_html/priv/static/phoenix_html.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix_html\");\n  (function() {\n    \"use strict\";\r\n\r\n(function() {\r\n  function buildHiddenInput(name, value) {\r\n    var input = document.createElement(\"input\");\r\n    input.type = \"hidden\";\r\n    input.name = name;\r\n    input.value = value;\r\n    return input;\r\n  }\r\n\r\n  function handleLinkClick(link) {\r\n    var message = link.getAttribute(\"data-confirm\");\r\n    if(message && !window.confirm(message)) {\r\n        return;\r\n    }\r\n\r\n    var to = link.getAttribute(\"data-to\"),\r\n        method = buildHiddenInput(\"_method\", link.getAttribute(\"data-method\")),\r\n        csrf = buildHiddenInput(\"_csrf_token\", link.getAttribute(\"data-csrf\")),\r\n        form = document.createElement(\"form\");\r\n\r\n    form.method = (link.getAttribute(\"data-method\") === \"get\") ? \"get\" : \"post\";\r\n    form.action = to;\r\n    form.style.display = \"hidden\";\r\n\r\n    form.appendChild(csrf);\r\n    form.appendChild(method);\r\n    document.body.appendChild(form);\r\n    form.submit();\r\n  }\r\n\r\n  window.addEventListener(\"click\", function(e) {\r\n    var element = e.target;\r\n\r\n    while (element && element.getAttribute) {\r\n      if(element.getAttribute(\"data-method\")) {\r\n        handleLinkClick(element);\r\n        e.preventDefault();\r\n        return false;\r\n      } else {\r\n        element = element.parentNode;\r\n      }\r\n    }\r\n  }, false);\r\n})();\n  })();\n});","\"use strict\";\n\nrequire(\"phoenix_html\");\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _phoenix = require(\"phoenix\");\n\nvar socket = new _phoenix.Socket(\"/socket\", { params: { token: window.userToken } });\n\n// When you connect, you'll often need to authenticate the client.\n// For example, imagine you have an authentication plug, `MyAuth`,\n// which authenticates the session and assigns a `:current_user`.\n// If the current user exists you can assign the user's token in\n// the connection for use in the layout.\n//\n// In your \"lib/web/router.ex\":\n//\n//     pipeline :browser do\n//       ...\n//       plug MyAuth\n//       plug :put_user_token\n//     end\n//\n//     defp put_user_token(conn, _) do\n//       if current_user = conn.assigns[:current_user] do\n//         token = Phoenix.Token.sign(conn, \"user socket\", current_user.id)\n//         assign(conn, :user_token, token)\n//       else\n//         conn\n//       end\n//     end\n//\n// Now you need to pass this token to JavaScript. You can do so\n// inside a script tag in \"lib/web/templates/layout/app.html.eex\":\n//\n//     <script>window.userToken = \"<%= assigns[:user_token] %>\";</script>\n//\n// You will need to verify the user token in the \"connect/2\" function\n// in \"lib/web/channels/user_socket.ex\":\n//\n//     def connect(%{\"token\" => token}, socket) do\n//       # max_age: 1209600 is equivalent to two weeks in seconds\n//       case Phoenix.Token.verify(socket, \"user socket\", token, max_age: 1209600) do\n//         {:ok, user_id} ->\n//           {:ok, assign(socket, :user, user_id)}\n//         {:error, reason} ->\n//           :error\n//       end\n//     end\n//\n// Finally, pass the token on connect as below. Or remove it\n// from connect if you don't care about authentication.\n\n// NOTE: The contents of this file will only be executed if\n// you uncomment its entry in \"assets/js/app.js\".\n\n// To use Phoenix channels, the first step is to import Socket\n// and connect at the socket path in \"lib/web/endpoint.ex\":\nsocket.connect();\n\n// Now that you are connected, you can join channels with a topic:\nvar channel = socket.channel(\"topic:subtopic\", {});\nchannel.join().receive(\"ok\", function (resp) {\n  console.log(\"Joined successfully\", resp);\n}).receive(\"error\", function (resp) {\n  console.log(\"Unable to join\", resp);\n});\n\nexports.default = socket;\n"]}